<?xml version="1.0" encoding="UTF-8"?>
<!--
This software is in the public domain under CC0 1.0 Universal plus a 
Grant of Patent License.

To the extent possible under law, the author(s) have dedicated all
copyright and related and neighboring rights to this software to the
public domain worldwide. This software is distributed without any
warranty.

You should have received a copy of the CC0 Public Domain Dedication
along with this software (see the LICENSE.md file). If not, see
<http://creativecommons.org/publicdomain/zero/1.0/>.
-->
<services xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://moqui.org/xsd/service-definition-3.xsd">

<!--
样机订单：
Test machine orders：
1、供应商样机直送客户
2、供应商样机先送公司，再送客户
3、公司样机送客户

-->

    <!-- ========== TestMachineOrder Header  ========== -->

    <service verb="create" noun="TestMachineOrder">
        <description>
            Create an TestMachineOrder (OrderHeader and one OrderPart).
            All parameters are optional so that this can be called transparently to create a shell/empty order.
        </description>
        <in-parameters>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderHeader" include="nonpk">
                <exclude field-name="grandTotal"/></auto-parameters>

            <parameter name="statusId" default-value="TMOHSOpen">
                <description>The initial statusId for both header and part.</description></parameter>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="visitId" default="ec.user.visitId"/>
            <parameter name="enteredByPartyId" default="ec.user.userAccount?.partyId"/>
            <parameter name="currencyUomId"><description>Defaults to PartyAcctgPreference.baseCurrencyUomId for whichever
                Party (customer or vendor) is an internal organization with an accounting preference record.</description></parameter>
            <parameter name="orderRevision" type="Integer" default="1"/>
        </in-parameters>
        <out-parameters>
            <parameter name="testMachineOrderId" required="true"/>
        </out-parameters>
        <actions>

            <if condition="!currencyUomId">
                <if condition="customerPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:customerPartyId]"/></if>
                <if condition="!partyAcctgPreference &amp;&amp; vendorPartyId">
                    <service-call name="mantle.ledger.LedgerServices.find#PartyAcctgPreference" out-map="context"
                            in-map="[organizationPartyId:vendorPartyId]"/></if>
                <set field="currencyUomId" from="partyAcctgPreference?.baseCurrencyUomId"/>
            </if>
            <!-- MAYBE: get this from configuration somewhere, needed beyond PartyAcctgPreference? -->
            <if condition="!currencyUomId"><set field="currencyUomId" value="RMB"/></if>

            <service-call name="create#beiyelin.testmachine.TestMachineOrderHeader" in-map="context" out-map="context"/>

            <if condition="customerPartyId">
                <!-- If customer is internal org and there is a facility get default ship dest contact info -->
                <entity-find entity-name="mantle.party.PartyRole" list="custOrgInternalList">
                    <econdition field-name="partyId" from="customerPartyId"/>
                    <econdition field-name="roleTypeId" value="OrgInternal"/></entity-find>
                <if condition="custOrgInternalList">
                    <service-call name="mantle.facility.ContactServices.get#FacilityDefaultShipDest"
                            in-map="context" out-map="context"/></if>

                <!-- if customer Party.shippingInstructions populate if none specified -->
                <if condition="!shippingInstructions">
                    <entity-find-one entity-name="mantle.party.Party" value-field="customerParty">
                        <field-map field-name="partyId" from="customerPartyId"/></entity-find-one>
                    <set field="shippingInstructions" from="customerParty?.shippingInstructions"/>
                </if>

            </if>


        </actions>
    </service>
    <service verb="update" noun="TestMachineOrderHeader">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderHeader" include="nonpk">
                <exclude field-name="statusId"/>
                <exclude field-name="orderRevision"/>
                <exclude field-name="grandTotal"/></auto-parameters>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/>
            <entity-set value-field="testMachineOrderHeader" include="nonpk" set-if-empty="true"/>
            <set field="testMachineOrderHeader.orderRevision" from="testMachineOrderHeader.orderRevision + 1"/>
            <entity-update value-field="testMachineOrderHeader"/>

        </actions>
    </service>

    <!-- ======================================== -->
    <!-- ========== OrderItem Services ========== -->
    <!-- ======================================== -->

    <service verb="get" noun="TestMachineOrderItemTotal">
        <in-parameters>
            <parameter name="testMachineOrderItem" type="EntityValue"><description>Can be a view-entity with OrderItem and at least
                the fields testMachineOrderId, testMachineOrderItemSeqId, unitAmount, quantity, selectedAmount.</description></parameter>
            <parameter name="getChildrenTotals" type="Boolean" default="false"/>
        </in-parameters>
        <out-parameters>
            <parameter name="combinedAmount" type="BigDecimal"><description>unitAmount (default 0.0) * selectedAmount (default 1.0)</description></parameter>
            <parameter name="combinedQuantity" type="BigDecimal"><description>quantity (1.0 if null) * selectedAmount (default 1.0)</description></parameter>
            <parameter name="itemTotal" type="BigDecimal"/>
            <parameter name="childrenTotal" type="BigDecimal"/>
            <parameter name="itemPlusChildrenTotal" type="BigDecimal"/>
            <parameter name="childItemCount" type="Integer"/>
            <parameter name="childOrderItemList" type="List">
                <parameter name="childOrderItem" type="Map"/>
            </parameter>
        </out-parameters>
        <actions>
            <!-- for return value, unitAmount * selectedAmount -->
            <set field="combinedAmount" from="((testMachineOrderItem.unitAmount ?: 0.0) * (testMachineOrderItem.selectedAmount ?: 1.0))"/>

            <set field="combinedQuantity" from="(testMachineOrderItem.quantity != null ? testMachineOrderItem.quantity : 1.0) * (testMachineOrderItem.selectedAmount ?: 1.0)"/>
            <!-- NOTE: also a sales/VAT tax calculation concern on item vs invoice level, but using 2 digits so consistent across order, invoice, GL TX entry
                (tax should generally be calculated to 3 digits on the item level then summed and rounded to 2 digits to get a tax total) -->
            <!-- NOTE: CurrencyRoundingMarker scale here may vary by currency, make configurable -->
            <set field="itemTotal" from="(combinedQuantity * (testMachineOrderItem.unitAmount as BigDecimal ?: 0.0)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
            <if condition="getChildrenTotals">
                <!-- recursively get total of child OrderItems -->
                <!-- don't use relationship, allow view-entities, etc <entity-find-related value-field="testMachineOrderItem" relationship-name="Child#OrderItem" list="childOrderItemList"/> -->
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="childOrderItemList">
                    <econdition field-name="testMachineOrderId" from="testMachineOrderItem.testMachineOrderId"/>
                    <econdition field-name="parentItemSeqId" from="testMachineOrderItem.testMachineOrderItemSeqId"/>
                </entity-find>
                <set field="childrenTotal" from="0.0"/>
                <set field="hasPromo" from="false"/>
                <set field="promoQuantityUsed" from="0.0"/>
                <iterate list="childOrderItemList" entry="childOrderItem">
                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.get#TestMachineOrderItemTotal" out-map="getOitResult" out-map-add-to-existing="false"
                            in-map="[testMachineOrderItem:childOrderItem, getChildrenTotals:true]"/>
                    <set field="childrenTotal" from="childrenTotal + getOitResult.itemPlusChildrenTotal"/>


                </iterate>
                <set field="itemPlusChildrenTotal" from="itemTotal + childrenTotal"/>
                <set field="childItemCount" from="childOrderItemList.size()"/>
            </if>
        </actions>
    </service>

    <service verb="create" noun="TestMachineOrderItem">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderItem" include="nonpk"/>
            <parameter name="itemTypeEnumId" default-value="ItemProduct"/>
            <parameter name="quantity" type="BigDecimal" default="1"/>
        </in-parameters>
        <out-parameters>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
        </out-parameters>
        <actions>
            <set field="isProductItem" from="false"/>
            <if condition="productId">
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                <if condition="product == null"><return error="true" message="Product ${productId} not found"/></if>
                <if condition="product.productTypeEnumId == 'PtVirtual'">
                    <return error="true" message="Product ${productId} is a Virtual product and may not be used on an TestMachineOrder"/></if>

                <!-- Is this a product item? -->
                <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                    <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
                <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
                <set field="isProductItem" from="itemTypeEnumId in productItemTypes"/>
            </if>


            <if condition="isProductItem"><then>
                <!-- set some product item defaults -->
                <if condition="product?.amountRequire == 'Y' &amp;&amp; !selectedAmount">
                    <return error="true" message="Product ${productId} requires a selected amount"/></if>
                <if condition="!itemDescription"><set field="itemDescription" from="product?.productName"/></if>
                <if condition="!quantityUomId"><set field="quantityUomId" from="product?.amountUomId"/></if>
            </then><else-if condition="parentItemSeqId">
                <!-- set productId from parent item -->
                <if condition="!productId">
                    <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="parentItem">
                        <field-map field-name="testMachineOrderId"/>
                        <field-map field-name="testMachineOrderItemSeqId" from="parentItemSeqId"/>
                    </entity-find-one>
                    <set field="productId" from="parentItem?.productId"/>
                </if>
            </else-if></if>

            <service-call name="create#beiyelin.testmachine.TestMachineOrderItem" in-map="context" out-map="context"/>
        </actions>
    </service>
    <service verb="update" noun="TestMachineOrderItem">
        <in-parameters>
            <auto-parameters include="pk" required="true"/>
            <auto-parameters include="nonpk"/>
            <parameter name="unitAmount_changeReason"/>
            <parameter name="quantity_changeReason"/>

        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem" for-update="true"/>
            <set field="productId" from="productId ?: testMachineOrderItem.productId"/>
            <set field="quantity" from="quantity != null ? quantity : testMachineOrderItem.quantity"/>

            <!-- is this a product item? -->
            <set field="isProductItem" from="false"/>
            <if condition="productId">
                <if condition="productId != testMachineOrderItem.productId">
                    <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                    <if condition="product == null"><return error="true" message="Product ${productId} not found"/></if>
                    <if condition="product.productTypeEnumId == 'PtVirtual'">
                        <return error="true" message="Product ${productId} is a Virtual product and may not be used on an TestMachineOrder"/></if>
                </if>

                <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                    <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
                <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
                <set field="isProductItem" from="productItemTypes.contains(testMachineOrderItem.itemTypeEnumId)"/>
            </if>

            <if condition="isProductItem"><then>
                <!-- logic for product items -->



                <!-- calculate the price based on quantity, etc, -->
                <if condition="unitAmount == null &amp;&amp; isProductItem"><then>
                    <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true"/>


                    <!-- use PriceServices.get#OrderProductPrice instead of calling to get price directly, for pricePurposeEnumId override for recurring orders and other future behavior:
                    <service-call name="mantle.product.PriceServices.get#ProductPrice" out-map="priceMap"
                            in-map="[productId:productId, quantity:quantity, priceUomId:testMachineOrderHeader.currencyUomId,
                                  productStoreId:testMachineOrderHeader.productStoreId, customerPartyId:orderPart.customerPartyId,
                                  vendorPartyId:orderPart.vendorPartyId]"/>
                    -->
                    <service-call name="mantle.product.PriceServices.get#OrderProductPrice" out-map="priceMap"
                            in-map="[productId:productId, quantity:quantity, testMachineOrderId:testMachineOrderId]"/>


                    <set field="unitAmount" from="priceMap.price"/>
                    <set field="unitListPrice" from="priceMap.listPrice"/>
                    <set field="isModifiedPrice" value="N"/>
                </then><else>
                    <set field="isModifiedPrice" value="Y"/>
                </else></if>

                <!-- on quantity changes adjust ShipmentItem/Source (only if some exist for 'open' shipments) -->
                <if condition="quantity != null &amp;&amp; quantity != testMachineOrderItem.quantity">
                    <entity-find entity-name="mantle.shipment.ShipmentAndItemSource" list="shipmentItemSourceList">
                        <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/>
                        <econdition field-name="shipmentStatusId" operator="in" value="ShipInput,ShipScheduled"/>
                        <order-by field-name="shipmentId"/>
                    </entity-find>
                    <if condition="shipmentItemSourceList">
                        <set field="sourceQuantityTotal" from="0"/>
                        <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                            <set field="sourceQuantityTotal" from="sourceQuantityTotal + shipmentItemSource.quantity"/></iterate>
                        <if condition="quantity &gt; sourceQuantityTotal"><then>
                            <set field="quantityIncrease" from="quantity - sourceQuantityTotal"/>
                            <!-- quantity increase, we don't know which shipment it should go on so just pick the first -->
                            <set field="shipmentItemSource" from="shipmentItemSourceList[0]"/>
                            <service-call name="update#mantle.shipment.ShipmentItemSource"
                                    in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                          quantity:(shipmentItemSource.quantity + quantityIncrease),
                                          quantityNotHandled:(shipmentItemSource.quantityNotHandled + quantityIncrease)]"/>

                            <!-- also update ShipmentItem.quantity -->
                            <entity-find-one entity-name="mantle.shipment.ShipmentItem" value-field="shipmentItem">
                                <field-map field-name="shipmentId" from="shipmentItemSource.shipmentId"/>
                                <field-map field-name="productId" from="testMachineOrderItem.productId"/></entity-find-one>
                            <service-call name="update#mantle.shipment.ShipmentItem"
                                    in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                          quantity:(shipmentItem.quantity + quantityIncrease)]"/>
                        </then><else>
                            <!-- a little more fun, deduct as available from each item in the list until all handled -->
                            <set field="quantityReduceRemaining" from="sourceQuantityTotal - quantity"/>
                            <iterate list="shipmentItemSourceList" entry="shipmentItemSource">
                                <set field="quantityReduce" from="quantityReduceRemaining &gt; shipmentItemSource.quantityNotHandled ?
                                    shipmentItemSource.quantityNotHandled : quantityReduceRemaining"/>
                                <if condition="quantityReduce == 0"><break/></if>
                                <service-call name="update#mantle.shipment.ShipmentItemSource"
                                        in-map="[shipmentItemSourceId:shipmentItemSource.shipmentItemSourceId,
                                        quantity:(shipmentItemSource.quantity - quantityReduce),
                                        quantityNotHandled:(shipmentItemSource.quantityNotHandled - quantityReduce)]"/>
                                <set field="quantityReduceRemaining" from="quantityReduceRemaining - quantityReduce"/>

                                <!-- also update ShipmentItem.quantity -->
                                <entity-find-one entity-name="mantle.shipment.ShipmentItem" value-field="shipmentItem">
                                    <field-map field-name="shipmentId" from="shipmentItemSource.shipmentId"/>
                                    <field-map field-name="productId" from="testMachineOrderItem.productId"/></entity-find-one>
                                <set field="newItemQuantity" from="shipmentItem.quantity &gt; quantityReduce ?
                                    shipmentItem.quantity - quantityReduce : 0.0"/>
                                <service-call name="update#mantle.shipment.ShipmentItem"
                                        in-map="[shipmentId:shipmentItem.shipmentId, productId:shipmentItem.productId,
                                        quantity:newItemQuantity]"/>
                            </iterate>
                        </else></if>
                    </if>
                </if>
            </then><else>
                <!-- logic for non-product items -->

                <!-- defaults from parent item -->
                <if condition="parentItemSeqId">
                    <!-- set productId from parent item -->
                    <if condition="!productId">
                        <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="parentItem">
                            <field-map field-name="testMachineOrderId"/>
                            <field-map field-name="testMachineOrderItemSeqId" from="parentItemSeqId"/>
                        </entity-find-one>
                        <set field="productId" from="parentItem?.productId"/>
                    </if>
                </if>
            </else></if>

            <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="context"/>
            <!-- leave this out, may be nice to have a way to easily ignore messages from a specific service call: <message>TestMachineOrder item ${testMachineOrderItemSeqId} updated</message> -->
        </actions>
    </service>
    <service verb="delete" noun="TestMachineOrderItem">
        <in-parameters><auto-parameters include="pk" required="true"/></in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem"/>
            <if condition="testMachineOrderItem == null"><return message="TestMachineOrder ${testMachineOrderId} item ${testMachineOrderItemSeqId} not found"/></if>

            <!-- delete item -->
            <service-call name="delete#beiyelin.testmachine.TestMachineOrderItem" in-map="context"/>

            <!-- explicitly call handle#TestMachineOrderMajorChange to trigger promo, shipping, tax calc -->
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.handle#TestMachineOrderMajorChange"
                    in-map="[testMachineOrderId:testMachineOrderItem.testMachineOrderId]"/>
        </actions>
    </service>

    <service verb="recalc" noun="TestMachineOrderItemAmount">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem" for-update="true"/>
            <if condition="testMachineOrderItem.productId == null"><return/></if>

            <!-- Is this a product item? -->
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
            <if condition="!(testMachineOrderItem.itemTypeEnumId in productItemTypes)">
                <return/></if>

            <!--TODO 这种计算价格的方式是否需要-->
            <service-call name="mantle.product.PriceServices.get#OrderProductPrice" out-map="priceOut"
                    in-map="[productId:testMachineOrderItem.productId, quantity:testMachineOrderItem.quantity, testMachineOrderId:testMachineOrderId]"/>

            <if condition="priceOut.price"><then>
                <if condition="priceOut.price != testMachineOrderItem.unitAmount">
                    <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId,
                        unitAmount:priceOut.price, unitListPrice:priceOut.listPrice, isModifiedPrice:'N']"/>
                </if>
            </then><else>
                <message type="warning">No price found for Product ${testMachineOrderItem.productId} on TestMachineOrder Item ${testMachineOrderId}:${testMachineOrderItemSeqId}, not resetting</message>
            </else></if>
        </actions>
    </service>

    <service verb="check" noun="AvailableInventory">
        <in-parameters>
            <parameter name="productId" required="true"/>
            <parameter name="quantity" type="BigDecimal" required="true"/>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId"/>
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore.requireInventory setting.</description></parameter>

            <parameter name="testMachineOrderHeader" type="EntityValue"/>
            <parameter name="productStore" type="EntityValue"/>
        </in-parameters>
        <actions>
            <if condition="requireInventory == null">
                <if condition="productStore == null">
                    <if condition="testMachineOrderHeader == null"><entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/></if>
                    <entity-find-one entity-name="mantle.product.store.ProductStore" value-field="productStore" cache="true">
                        <field-map field-name="productStoreId" from="testMachineOrderHeader.productStoreId"/></entity-find-one>
                </if>
                <set field="requireInventory" from="productStore?.requireInventory == 'Y'"/>
            </if>
            <!-- if available inventory not required return now -->
            <if condition="!requireInventory"><return/></if>
            <!-- get current available inventory -->
            <!--TODO 这个服务需要更新-->
            <service-call name="mantle.product.AssetServices.get#AvailableForOrder" out-map="availOut"
                    in-map="[productId:productId, testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId, testMachineOrderItemSeqId:testMachineOrderItemSeqId,
                        testMachineOrderHeader:testMachineOrderHeader, orderPart:orderPart]"/>
            <set field="availableToPromiseTotal" from="availOut.availableToPromiseTotal"/>
            <!-- if out of stock show one message, if insufficient available show another -->
            <if condition="availableToPromiseTotal &lt; quantity">
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true"/>
                <if condition="availableToPromiseTotal &lt;= 0.0"><then>
                    <message public="true" type="warning">OrderInventoryNotAvailable</message>
                    <return error="true" message="Inventory not available, not updating testMachineOrder ${testMachineOrderId}:${orderItemSeqId} product ${productId} for quantity ${quantity}"/>
                </then><else>
                    <message public="true" type="warning">OrderInventoryInsufficient</message>
                    <return error="true" message="Inventory insufficient, not updating testMachineOrder ${testMachineOrderId}:${orderItemSeqId} product ${productId} for quantity ${quantity}"/>
                </else></if>
            </if>
        </actions>
    </service>

    <service verb="merge" noun="TestMachineOrderItems">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="fromOrderId" required="true"/>
        </in-parameters>
        <actions>
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="orderItemList">
                <econdition field-name="testMachineOrderId" from="fromOrderId"/></entity-find>
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
            <iterate list="orderItemList" entry="testMachineOrderItem">
                <if condition="!testMachineOrderItem.productId || !productItemTypes.contains(testMachineOrderItem.itemTypeEnumId)"><continue/></if>
                <service-call name="beiyelin.testmachine.TestMachineOrderServices.add#TestMachineOrderProductQuantity"
                        in-map="[testMachineOrderId:testMachineOrderId, productId:testMachineOrderItem.productId, quantity:testMachineOrderItem.quantity]"/>
            </iterate>
        </actions>
    </service>

    <!-- ===================================================== -->
    <!-- ========== TestMachineOrder Billing/Shipping Services ========== -->
    <!-- ===================================================== -->

    <service verb="set" noun="TestMachineOrderBillingShippingInfo">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="orderPartSeqId"/>
            <parameter name="paymentId"/>

            <parameter name="paymentInstrumentEnumId"/>
            <parameter name="paymentMethodId"/>
            <parameter name="toPaymentMethodId"/>
            <parameter name="finAccountId"/>
            <parameter name="shippingFacilityId"/>
            <parameter name="shippingPostalContactMechId"/>
            <parameter name="shippingTelecomContactMechId"/>

            <parameter name="carrierAndShipmentMethod"/>
            <parameter name="carrierPartyId"/>
            <parameter name="shipmentMethodEnumId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="paymentId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true"/>
            <if condition="orderPartSeqId"><then>
                <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderPart" value-field="orderPart" for-update="true"/>
            </then><else>
                <!-- just get the first part -->
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderPart" list="orderPartList">
                    <econdition field-name="testMachineOrderId"/>
                    <order-by field-name="orderPartSeqId"/>
                </entity-find>
                <set field="orderPart" from="orderPartList.first"/>
                <set field="orderPartSeqId" from="orderPart.orderPartSeqId"/>
            </else></if>

            <if condition="shippingPostalContactMechId &amp;&amp; !shippingTelecomContactMechId">
                <entity-find-one entity-name="mantle.party.contact.PostalAddress" value-field="shippingPostalAddress">
                    <field-map field-name="contactMechId" from="shippingPostalContactMechId"/></entity-find-one>
                <set field="shippingTelecomContactMechId" from="shippingPostalAddress.telecomContactMechId"/>
            </if>

            <set field="canUpdateShippingInfo" from="true"/>
            <!-- Find the shipment IDs for this testMachineOrder part -->
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="shipmentItemSourceList">
                <econdition field-name="testMachineOrderId"/></entity-find>
            <if condition="shipmentItemSourceList">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="partOrderItemList">
                    <econdition field-name="testMachineOrderId"/><econdition field-name="orderPartSeqId"/></entity-find>
                <script>
                    List orderItemSeqIdList = partOrderItemList.testMachineOrderItemSeqId
                    partShipmentIdSet = new TreeSet()
                    for (Map sis in shipmentItemSourceList) if (sis.testMachineOrderItemSeqId in orderItemSeqIdList) {
                        partShipmentIdSet.add(sis.shipmentId)
                    }
                </script>

                <!-- Update shipment method and shipping address on the last route segment(s) of this testMachineOrder part -->
                <iterate list="partShipmentIdSet" entry="shipmentId">
                    <entity-find-one entity-name="mantle.shipment.Shipment" value-field="shipment"/>
                    <if condition="shipment.statusId in ['ShipRejected', 'ShipCancelled']"><continue/></if>
                    <if condition="shipment.statusId in ['ShipPacked', 'ShipShipped', 'ShipDelivered']">
                        <message type="danger" public="true">Not updating shipping info, Shipment ${shipmentId} is ${shipment.status?.description}</message>
                        <set field="canUpdateShippingInfo" from="false"/>
                    </if>
                </iterate>
            </if>

            <if condition="canUpdateShippingInfo">
                <if condition="partShipmentIdSet">
                    <iterate list="partShipmentIdSet" entry="shipmentId">
                        <entity-find entity-name="mantle.shipment.ShipmentRouteSegment" list="shipmentRouteSegments">
                            <econdition field-name="shipmentId"/><order-by field-name="-shipmentRouteSegmentSeqId"/></entity-find>
                        <if condition="shipmentRouteSegments">
                            <set field="shipmentRouteSegment" from="shipmentRouteSegments[0]"/>
                            <set field="shipmentRouteSegment.shipmentMethodEnumId" from="shipmentMethodEnumId" set-if-empty="false"/>
                            <set field="shipmentRouteSegment.destPostalContactMechId" from="shippingPostalContactMechId" set-if-empty="false"/>
                            <set field="shipmentRouteSegment.destTelecomContactMechId" from="shippingTelecomContactMechId" set-if-empty="false"/>
                            <entity-update value-field="shipmentRouteSegment"/>
                        </if>
                    </iterate>
                </if>

                <if condition="shippingFacilityId"><set field="orderPart.facilityId" from="shippingFacilityId"/></if>
                <if condition="shippingPostalContactMechId"><set field="orderPart.postalContactMechId" from="shippingPostalContactMechId"/></if>
                <if condition="shippingTelecomContactMechId"><set field="orderPart.telecomContactMechId" from="shippingTelecomContactMechId"/></if>
                <if condition="carrierAndShipmentMethod">
                    <set field="carrierPartyId" from="carrierAndShipmentMethod.split(':')[0]"/>
                    <set field="shipmentMethodEnumId" from="carrierAndShipmentMethod.split(':')[1]"/>
                </if>
                <if condition="carrierPartyId"><set field="orderPart.carrierPartyId" from="carrierPartyId"/></if>
                <if condition="shipmentMethodEnumId"><set field="orderPart.shipmentMethodEnumId" from="shipmentMethodEnumId"/></if>
                <entity-update value-field="orderPart"/>
            </if>

            <if condition="paymentId">
                <entity-find-one entity-name="mantle.account.payment.Payment" value-field="payment"/>
                <if condition="payment != null &amp;&amp; (payment.testMachineOrderId != testMachineOrderId || payment.orderPartSeqId != orderPartSeqId)">
                    <!-- don't allow updating/hijacking this payment, whatever it was for -->
                    <set field="payment" from="null"/>
                    <set field="paymentId" from="null"/>
                </if>
            </if>

            <if condition="payment == null">
                <!-- try the first payment for the part -->
                <entity-find entity-name="mantle.account.payment.Payment" list="paymentList">
                    <econdition field-name="testMachineOrderId"/>
                    <econdition field-name="orderPartSeqId"/>
                    <order-by field-name="paymentId"/>
                </entity-find>
                <set field="payment" from="paymentList.first"/>
            </if>

            <if condition="payment != null"><then>
                <!-- update existing payment -->
                <if condition="paymentMethodId"><set field="payment.paymentMethodId" from="paymentMethodId"/></if>
                <if condition="toPaymentMethodId"><set field="payment.toPaymentMethodId" from="toPaymentMethodId"/></if>
                <if condition="finAccountId"><set field="payment.finAccountId" from="finAccountId"/></if>
                <entity-update value-field="payment"/>
                <set field="paymentId" from="payment.paymentId"/>
            </then><else-if condition="paymentMethodId || paymentInstrumentEnumId || finAccountId">
                <!-- create a new Payment for the TestMachineOrder -->
                <service-call name="beiyelin.testmachine.TestMachineOrderServices.add#OrderPartPayment" out-map="context"
                        in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId, paymentInstrumentEnumId:paymentInstrumentEnumId,
                            paymentMethodId:paymentMethodId, toPaymentMethodId:toPaymentMethodId, finAccountId:finAccountId]"/>
            </else-if></if>
        </actions>
    </service>
    <service verb="add" noun="TestMachineOrderPartPayment">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.payment.Payment" include="nonpk"><exclude field-name="amountUomId"/>
                <exclude field-name="fromPartyId"/><exclude field-name="toPartyId"/><exclude field-name="acctgTransResultEnumId"/>
                <exclude field-name="reconcileStatusId"/><exclude field-name="paymentMethodFileId"/></auto-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="paymentTypeEnumId" default-value="PtInvoicePayment"/>
            <parameter name="statusId" default-value="PmntPromised"/>
            <parameter name="amount" type="BigDecimal"><description>Defaults to OrderPart.partTotal</description></parameter>
            <parameter name="visitId" default="ec.user.visitId"/>
            <parameter name="settlementTermId"/>
        </in-parameters>
        <out-parameters>
            <parameter name="paymentId"/>
        </out-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderPart" value-field="orderPart"/>

            <set field="fromPartyId" from="orderPart.customerPartyId"/>
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderPartParty" list="billToList">
                <econdition field-name="testMachineOrderId"/><econdition field-name="orderPartSeqId"/>
                <econdition field-name="roleTypeId" value="CustomerBillTo"/>
            </entity-find>
            <if condition="billToList"><set field="fromPartyId" from="billToList[0].partyId"/></if>

            <set field="amountUomId" from="testMachineOrderHeader.currencyUomId"/>
            <set field="toPartyId" from="orderPart.vendorPartyId"/>

            <if condition="settlementTermId">
                <entity-find-one entity-name="mantle.account.invoice.SettlementTerm" value-field="settlementTerm" cache="true"/>
                <if condition="!settlementTerm?.orderPmtServiceRegisterId">
                    <message type="warning">Selected Term has no Auto Payments Service, creating a single Payment</message></if>
            </if>

            <if condition="settlementTerm?.orderPmtServiceRegisterId"><then>
                <service-call name="update#beiyelin.testmachine.TestMachineOrderPart"
                        in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId, settlementTermId:settlementTermId]"/>

                <entity-find-one entity-name="moqui.service.ServiceRegister" value-field="serviceRegister">
                    <field-map field-name="serviceRegisterId" from="settlementTerm.orderPmtServiceRegisterId"/></entity-find-one>
                <script><![CDATA[
                    try {
                        ec.service.sync().name(serviceRegister.serviceName).parameters(context).softValidate(true).disableAuthz().call()
                        if (ec.message.hasError()) return
                    } catch (Throwable t) {
                        ec.logger.log(300, "Error calling auto testMachineOrder payments service for SettlementTerm ${settlementTermId}", t)
                    }
                ]]></script>
            </then><else>
                <service-call name="mantle.account.PaymentServices.create#Payment" out-map="context"
                        in-map="context + [amount:amount, amountUomId:amountUomId, fromPartyId:fromPartyId, toPartyId:toPartyId]"/>
            </else></if>
        </actions>
    </service>

    <service verb="create" noun="TestMachineOrderPayments50Split">
        <in-parameters>
            <auto-parameters entity-name="mantle.account.payment.Payment" include="nonpk"><exclude field-name="amountUomId"/>
                <exclude field-name="acctgTransResultEnumId"/><exclude field-name="reconcileStatusId"/>
                <exclude field-name="paymentMethodFileId"/></auto-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="orderPartSeqId"/>
            <parameter name="dueDate" type="Timestamp"/>
            <parameter name="paymentTypeEnumId" default-value="PtInvoicePayment"/>
            <parameter name="statusId" default-value="PmntPromised"/>
            <parameter name="amount" type="BigDecimal"><description>Defaults to OrderPart.partTotal</description></parameter>
            <parameter name="visitId" default="ec.user.visitId"/>
            <parameter name="settlementTermId"/>
        </in-parameters>
        <actions>
            <set field="amount" from="amount ?: orderPart.partTotal"/>
            <if condition="amount == 0.0"><return message="Amount is 0.00, not creating Payments"/></if>

            <set field="advanceAmount" from="amount.divide(2.0, BigDecimal.ROUND_HALF_UP)"/>
            <set field="remainingAmount" from="amount - advanceAmount"/>

            <service-call name="mantle.account.PaymentServices.create#Payment" out-map="advanceOut"
                    in-map="context + [amount:advanceAmount]"/>
            <service-call name="mantle.account.PaymentServices.create#Payment" out-map="remainingOut"
                    in-map="context + [amount:remainingAmount, dueDate:null]"/>
        </actions>
    </service>

    <!-- ================================================== -->
    <!-- ========== TestMachineOrder Status Change Services ========== -->
    <!-- ================================================== -->

    <service verb="change" noun="TestMachineOrderStatusInterface" type="interface">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="oldStatusId"/>
            <parameter name="statusChanged" type="Boolean"/>
        </out-parameters>
    </service>
    <service verb="update" noun="TestMachineOrderStatus">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="statusId" required="true"/>
            <parameter name="placedDate" type="Timestamp"/>
            <parameter name="approvedDate" type="Timestamp"/>
            <parameter name="completedDate" type="Timestamp"/>
        </in-parameters>
        <out-parameters><parameter name="oldStatusId"/><parameter name="statusChanged" type="Boolean"/></out-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true"/>

            <set field="updateMap" from="[testMachineOrderId:testMachineOrderId, statusId:statusId]"/>
            <if condition="placedDate != null &amp;&amp; testMachineOrderHeader.placedDate == null"><script>updateMap.put('placedDate', placedDate)</script></if>
            <if condition="approvedDate != null &amp;&amp; testMachineOrderHeader.approvedDate == null"><script>updateMap.put('approvedDate', approvedDate)</script></if>
            <if condition="completedDate != null &amp;&amp; testMachineOrderHeader.completedDate == null"><script>updateMap.put('completedDate', completedDate)</script></if>
            <service-call name="update#beiyelin.testmachine.TestMachineOrderHeader" out-map="context" in-map="updateMap"/>
        </actions>
    </service>
    <service verb="propose" noun="TestMachineOrder">
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>
        <actions><service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus" out-map="context" in-map="context + [statusId:'OrderProposed']"/></actions>
    </service>
    <service verb="place" noun="TestMachineOrder">
        <!-- this used to use transaction="cache" but with record locks (for asset reservation) it is unreliable, gets old data from the TX cache -->
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>
        <in-parameters>
            <parameter name="placedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="requireInventory" type="Boolean">
                <description>If true make sure inventory is available, if false don't check. If null defer to ProductStore.requireInventory setting.</description></parameter>
        </in-parameters>
        <actions>
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus" out-map="context"
                    in-map="context + [statusId:'OrderPlaced', placedDate:placedDate]"/>

            <!-- if requireInventory make sure all is available (or was reserved) -->
            <!-- NOTE: do this AFTER the update#TestMachineOrderStatus call so that transactional reservation is already done and we know if we were able to reserve all (or if reservation not done that all is available) -->

            <if condition="requireInventory">
                <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                    <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
                <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>

                <if condition="testMachineOrderHeader == null"><entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader"/></if>
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="orderItemList">
                    <econdition field-name="testMachineOrderId"/>
                    <econdition field-name="productId" operator="is-not-null"/>
                    <!-- testMachineOrder by productId to avoid deadlocks -->
                    <order-by field-name="productId"/>
                </entity-find>

                <set field="allInventoryAvailable" from="true"/>
                <iterate list="orderItemList" entry="testMachineOrderItem">
                    <set field="isProductItem" from="productItemTypes.contains(testMachineOrderItem.itemTypeEnumId) &amp;&amp; testMachineOrderItem.productId"/>
                    <if condition="!isProductItem"><continue/></if>

                    <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true">
                        <field-map field-name="productId" from="testMachineOrderItem.productId"/></entity-find-one>
                    <if condition="!(product?.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse', 'PtPickAssembly'])">
                        <continue/></if>

                    <!-- get current available inventory TODO 需要更新库存获取方式 -->
                    <service-call name="mantle.product.AssetServices.get#AvailableForOrder" out-map="availOut" out-map-add-to-existing="false"
                            in-map="[productId:testMachineOrderItem.productId, testMachineOrderId:testMachineOrderId, orderPartSeqId:testMachineOrderItem.orderPartSeqId,
                                testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId, testMachineOrderHeader:testMachineOrderHeader]"/>
                    <set field="availableToPromiseTotal" from="availOut.availableToPromiseTotal"/>
                    <!-- if out of stock show one message, if insufficient available show another -->
                    <if condition="availableToPromiseTotal &lt; testMachineOrderItem.quantity">
                        <set field="allInventoryAvailable" from="false"/>
                        <if condition="availableToPromiseTotal &lt;= 0.0"><then>
                            <message public="true" type="warning">OrderInventoryNotAvailable</message>
                        </then><else>
                            <message public="true" type="warning">OrderInventoryInsufficient</message>
                        </else></if>
                    </if>
                </iterate>

                <if condition="!allInventoryAvailable">
                    <!-- NOTE: return with error=true will cause TX rollback, including reservations -->
                    <return error="true" message="Inventory required but not all available, not placing testMachineOrder ${testMachineOrderId}"/>
                </if>
            </if>

        </actions>
    </service>
    <service verb="approve" noun="TestMachineOrder">
        <description>For manual testMachineOrder approval, requires ORDER_APPROVE permission.</description>
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#OrderStatusInterface"/>
        <in-parameters>
            <parameter name="approvedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions>
            <if condition="!ec.user.hasPermission('ORDER_APPROVE')">
                <return error="true" message="TestMachineOrder Approve permission required"/></if>
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus" out-map="context" in-map="context + [statusId:'OrderApproved']"/>
        </actions>
    </service>


    <service verb="isFulfilled" noun="TestMachineOrderItem">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
            <!-- optional fields for efficiency, each if null will be queried -->
            <parameter name="testMachineOrderItem" type="EntityValue"/>
            <parameter name="orderSubscriptionList" type="List"/>
            <parameter name="orderWorkEffortList" type="List"/>
            <parameter name="orderAssetIssuanceList" type="List"/>
            <parameter name="orderAssetReceiptList" type="List"/>
        </in-parameters>
        <out-parameters><parameter name="isFulfilled" type="Boolean"/></out-parameters>
        <actions>
            <if condition="testMachineOrderItem == null"><entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem"/></if>

            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>

            <!-- set to true, if any evidence found that it is not fulfilled will set to false -->
            <set field="isFulfilled" from="true"/>
            <if condition="testMachineOrderItem.productId &amp;&amp; productItemTypes.contains(testMachineOrderItem.itemTypeEnumId)"><then>
                <entity-find-one entity-name="mantle.product.Product" value-field="product" cache="true">
                    <field-map field-name="productId" from="testMachineOrderItem.productId"/></entity-find-one>

                <if condition="product.productTypeEnumId in ['PtDigital', 'PtDigitalAsset']">
                    <if condition="orderSubscriptionList == null">
                        <entity-find entity-name="mantle.product.subscription.Subscription" list="orderSubscriptionList">
                            <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/></entity-find>
                    </if>
                    <entity-find entity-name="mantle.product.subscription.ProductSubscriptionResource"
                            list="productSubscriptionResourceList" cache="true">
                        <econdition field-name="productId" from="product.productId"/></entity-find>
                    <iterate list="productSubscriptionResourceList" entry="productSubscriptionResource">
                        <filter-map-list list="orderSubscriptionList" to-list="currentSubscriptionList">
                            <field-map field-name="testMachineOrderItemSeqId" from="testMachineOrderItem.testMachineOrderItemSeqId"/>
                            <field-map field-name="subscriptionResourceId" from="productSubscriptionResource.subscriptionResourceId"/>
                        </filter-map-list>
                        <if condition="!currentSubscriptionList">
                            <set field="isFulfilled" from="false"/>
                        </if>
                    </iterate>
                </if>
                <if condition="isFulfilled &amp;&amp; product.productTypeEnumId in ['PtAsset', 'PtDigitalAsset', 'PtAssetUse', 'PtPickAssembly']">
                    <if condition="orderAssetIssuanceList == null"><then>
                        <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="currentAssetIssuanceList">
                            <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/></entity-find>
                    </then><else>
                        <filter-map-list list="orderAssetIssuanceList" to-list="currentAssetIssuanceList">
                            <field-map field-name="testMachineOrderItemSeqId"/></filter-map-list>
                    </else></if>
                    <if condition="orderAssetReceiptList == null"><then>
                        <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="currentAssetIssuanceList">
                            <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/></entity-find>
                    </then><else>
                        <filter-map-list list="orderAssetReceiptList" to-list="currentAssetReceiptList">
                            <field-map field-name="testMachineOrderItemSeqId"/></filter-map-list>
                    </else></if>

                    <!-- add up quantity in currentAssetIssuanceList, compare to testMachineOrderItem.quantity -->
                    <set field="currentQuantityTotal" from="0" type="BigDecimal"/>
                    <iterate list="currentAssetIssuanceList" entry="currentAssetIssuance">
                        <set field="currentQuantityTotal" from="currentQuantityTotal + currentAssetIssuance.quantity"/>
                    </iterate>
                    <iterate list="currentAssetReceiptList" entry="currentAssetReceipt">
                        <set field="currentQuantityTotal" from="currentQuantityTotal + currentAssetReceipt.quantityAccepted"/>
                    </iterate>
                    <if condition="currentQuantityTotal &lt; testMachineOrderItem.quantity">
                        <set field="isFulfilled" from="false"/>
                    </if>
                </if>

            </then><else>
                <!-- TODO: for non-product items look for parent that is fulfilled? -->
                <!-- NOTE 2021-02-12 this service is only used to check isFulfilled#OrderPart so far, so this alternate definition of fulfilled isn't needed -->
            </else></if>
        </actions>
    </service>


    <service verb="complete" noun="TestMachineOrder">
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>
        <in-parameters>
            <parameter name="completedDate" type="Timestamp" default="ec.user.nowTimestamp"/>
        </in-parameters>
        <actions><service-call name="beiyelin.testmachine.TestMachineOrderServices.update#TestMachineOrderStatus" out-map="context" in-map="context + [statusId:'OrderCompleted']"/></actions>
    </service>

    <service verb="cancel" noun="TestMachineOrder">
        <description>Call when customer cancels the order. If no items shipped the testMachineOrder will be Cancelled.
            If partially shipped all items will be reduced to shipped quantity and the testMachineOrder will be Completed.</description>
        <implements service="beiyelin.testmachine.TestMachineOrderServices.change#TestMachineOrderStatusInterface"/>
        <!-- TODO add reject parameter to use OrderRejected status instead of OrderCancelled -->
        <actions>
            <!-- does partial cancel if already partially shipped, and then set what is left as completed; otherwise does a full cancel -->
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true"/>
            <if condition="testMachineOrderHeader == null"><return error="true" message="TestMachineOrder ${testMachineOrderId} not found"/></if>
            <if condition="testMachineOrderHeader.statusId == 'OrderCompleted'"><return error="true" message="Cannot cancel test machine testMachineOrder ${testMachineOrderId}, already Completed"/></if>
            <if condition="testMachineOrderHeader.statusId in ['OrderRejected', 'OrderCancelled']">
                <return message="Test Machine TestMachineOrder ${testMachineOrderId} already Cancelled"/></if>

            <!-- cancel item quantities not issued, update or remove ShipmentItemSource records, remove asset reservations if any -->
            <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="fullAssetIssuanceList">
                <econdition field-name="testMachineOrderId"/></entity-find>
            <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="fullShipmentItemSourceList">
                <econdition field-name="testMachineOrderId"/></entity-find>

            <set field="quantityIssued" from="0.0"/>
            <iterate list="fullAssetIssuanceList" entry="assetIssuance">
                <set field="quantityIssued" from="quantityIssued + assetIssuance.quantity"/></iterate>
            <set field="hasIssuedQuantity" from="quantityIssued &gt; 0.0"/>

            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="orderItemList">
                <econdition field-name="testMachineOrderId"/></entity-find>
            <iterate list="orderItemList" entry="testMachineOrderItem">
                <service-call name="beiyelin.testmachine.TestMachineOrderServices.cancel#TestMachineOrderItem" out-map="itemOut" out-map-add-to-existing="false"
                        in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId, testMachineOrderItem:testMachineOrderItem, checkCancelPart:false,
                            fullAssetIssuanceList:fullAssetIssuanceList, fullShipmentItemSourceList:fullShipmentItemSourceList]"/>
            </iterate>


            <!-- cancel or complete testMachineOrder header -->
            <service-call name="update#beiyelin.testmachine.TestMachineOrderHeader" out-map="context"
                    in-map="[testMachineOrderId:testMachineOrderId, statusId:targetStatusId]"/>
        </actions>
    </service>

    <service verb="cancel" noun="TestMachineOrderItem" no-tx-cache="true">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId" required="true"/>
            <parameter name="cancelQuantity" type="BigDecimal">
                <description>Defaults to quantity not yet issued, if greater than quantity not issued will be reduced to quantity not issued</description></parameter>
            <parameter name="testMachineOrderItem" type="EntityValue"/>
            <parameter name="fullAssetIssuanceList" type="List"><parameter name="assetIssuance" type="EntityValue"/></parameter>
            <parameter name="fullShipmentItemSourceList" type="List"><parameter name="shipmentItemSource" type="EntityValue"/></parameter>
            <parameter name="checkCancelPart" type="Boolean" default="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="hasIssuedQuantity" type="Boolean"/>
            <parameter name="quantityCancelled" type="BigDecimal"/>
        </out-parameters>
        <actions>
            <if condition="testMachineOrderItem == null"><entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderItem" value-field="testMachineOrderItem"/></if>
            <if condition="testMachineOrderItem == null"><return error="true" message="Test Machine TestMachineOrder Item ${testMachineOrderId}:${testMachineOrderItemSeqId} not found"/></if>

            <!-- only do this for product items -->
            <if condition="!testMachineOrderItem.productId"><return/></if>
            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>
            <if condition="!productItemTypes.contains(testMachineOrderItem.itemTypeEnumId)">
                <return type="warning" message="Item ${testMachineOrderItemSeqId} is not a product type item, not closing"/></if>

            <!-- check quantity issued -->
            <if condition="fullAssetIssuanceList"><then>
                <filter-map-list list="fullAssetIssuanceList" to-list="itemAssetIssuanceList">
                    <field-map field-name="testMachineOrderItemSeqId"/>
                    <field-map field-name="productId" from="testMachineOrderItem.productId"/>
                </filter-map-list>
            </then><else>
                <entity-find entity-name="mantle.product.issuance.AssetIssuance" list="itemAssetIssuanceList">
                    <econdition field-name="testMachineOrderId"/>
                    <econdition field-name="testMachineOrderItemSeqId"/>
                    <econdition field-name="productId" from="testMachineOrderItem.productId"/>
                </entity-find>
            </else></if>

            <set field="itemQuantityIssued" from="0.0"/>
            <iterate list="itemAssetIssuanceList" entry="itemAssetIssuance">
                <set field="itemQuantityIssued" from="itemQuantityIssued + itemAssetIssuance.quantity"/></iterate>
            <set field="hasIssuedQuantity" from="itemQuantityIssued &gt; 0.0"/>

            <!-- determine quantity to cancel -->
            <set field="itemQuantity" from="testMachineOrderItem.quantity != null ? testMachineOrderItem.quantity : 1.0"/>
            <set field="notIssuedQuantity" from="itemQuantity - itemQuantityIssued"/>
            <if condition="notIssuedQuantity &lt; 0.0">
                <log level="warn" message="In cancel#TestMachineOrderItem itemQuantityIssued ${itemQuantityIssued} is greater than itemQuantity ${itemQuantity}, using 0.0 for notIssuedQuantity instead of ${notIssuedQuantity}"/>
                <set field="notIssuedQuantity" from="0.0"/>
            </if>
            <if condition="cancelQuantity"><then>
                <if condition="cancelQuantity &gt; notIssuedQuantity"><then>
                    <set field="quantityCancelled" from="notIssuedQuantity"/>
                    <message type="warning">Cannot cancel quantity ${cancelQuantity}, only ${notIssuedQuantity} not yet shipped for TestMachineOrder Item ${testMachineOrderId}:${testMachineOrderItemSeqId}</message>
                </then><else>
                    <set field="quantityCancelled" from="cancelQuantity"/>
                </else></if>
            </then><else>
                <set field="quantityCancelled" from="notIssuedQuantity"/>
            </else></if>

            <if condition="!quantityCancelled"><return/></if>

            <!-- update the OrderItem -->
            <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId,
                        testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId,
                        quantityCancelled:(quantityCancelled + (testMachineOrderItem.quantityCancelled ?: 0)),
                        quantity:(itemQuantity - quantityCancelled)]"/>

            <!-- adjust child items (usually discount and tax) for new quantity -->
            <!-- NOTE this is simpler than other prorating because it is only done once, then the item is either completed if partially filled or cancelled otherwise -->
            <!-- NOTE skip discounts if isPromo=Y? those will be handled by testMachineOrder update triggers, if enabled; maybe best to calc here and disable promo calc (are disabled by default for orders Approved, etc) -->
            <if condition="itemQuantity == quantityCancelled"><then>
                <set field="childCancelRatio" from="1.0"/>
            </then><else>
                <set field="childCancelRatio" from="(quantityCancelled as BigDecimal).divide(itemQuantity as BigDecimal, 6, BigDecimal.ROUND_HALF_EVEN)"/>
            </else></if>
            <set field="childOrderItemList" from="testMachineOrderItem.'Child#beiyelin.testmachine.TestMachineOrderItem'"/>
            <order-map-list list="childOrderItemList"><order-by field-name="testMachineOrderItemSeqId"/></order-map-list>
            <iterate list="childOrderItemList" entry="childOrderItem">
                <if condition="childOrderItem.quantity == 0.0 || childOrderItem.unitAmount == 0.0"><continue/></if>
                <if condition="childOrderItem.quantity == itemQuantity"><then>
                    <!-- if child qty == parent qty no need to prorate, just adjust quantities to match -->
                    <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId,
                        testMachineOrderItemSeqId:childOrderItem.testMachineOrderItemSeqId,
                        quantityCancelled:(quantityCancelled + (childOrderItem.quantityCancelled ?: 0)),
                        quantity:(itemQuantity - quantityCancelled)]"/>
                </then><else>
                    <!-- quantity doesn't match, leave quantity alone and prorate unitAmount -->
                    <set field="newUnitAmount" from="childOrderItem.unitAmount - ((childCancelRatio as BigDecimal) * (childOrderItem.unitAmount as BigDecimal)).setScale(2, BigDecimal.ROUND_HALF_UP)"/>
                    <service-call name="update#beiyelin.testmachine.TestMachineOrderItem" in-map="[testMachineOrderId:testMachineOrderId,
                        testMachineOrderItemSeqId:childOrderItem.testMachineOrderItemSeqId, unitAmount:newUnitAmount]"/>
                </else></if>
            </iterate>

            <!-- update or remove ShipmentItemSource records -->
            <if condition="fullShipmentItemSourceList"><then>
                <filter-map-list list="fullShipmentItemSourceList" to-list="itemShipmentItemSourceList">
                    <field-map field-name="testMachineOrderItemSeqId"/></filter-map-list>
            </then><else>
                <entity-find entity-name="mantle.shipment.ShipmentItemSource" list="itemShipmentItemSourceList">
                    <econdition field-name="testMachineOrderId"/><econdition field-name="testMachineOrderItemSeqId"/></entity-find>
            </else></if>

            <set field="shipmentItemQuantityReducedMap" from="[:]"/>
            <set field="shipQuantityRemaining" from="quantityCancelled"/>
            <iterate list="itemShipmentItemSourceList" entry="itemShipmentItemSource">
                <set field="shipQuantityToReduce" from="shipQuantityRemaining &gt; itemShipmentItemSource.quantityNotHandled ?
                        itemShipmentItemSource.quantityNotHandled : shipQuantityRemaining"/>
                <if condition="!shipQuantityToReduce"><continue/></if>
                <script>addToBigDecimalInMap(itemShipmentItemSource.shipmentId, shipQuantityToReduce, shipmentItemQuantityReducedMap)</script>
                <!-- reduce quantity by quantityNotHandled -->
                <service-call name="update#mantle.shipment.ShipmentItemSource"
                        in-map="[shipmentItemSourceId:itemShipmentItemSource.shipmentItemSourceId, quantityNotHandled:0,
                                quantity:(itemShipmentItemSource.quantity - shipQuantityToReduce)]"/>

                <set field="shipQuantityRemaining" from="shipQuantityRemaining - shipQuantityToReduce"/>
            </iterate>

            <iterate list="shipmentItemQuantityReducedMap" entry="shipmentItemQuantityReduced" key="shipmentId">
                <entity-find-one entity-name="mantle.shipment.ShipmentItem" value-field="shipmentItem">
                    <field-map field-name="shipmentId"/><field-map field-name="productId" from="testMachineOrderItem.productId"/></entity-find-one>
                <if condition="shipmentItem != null">
                    <set field="newSiQuantity" from="shipmentItem.quantity &gt; shipmentItemQuantityReduced ?
                                shipmentItem.quantity - shipmentItemQuantityReduced : 0.0"/>
                    <service-call name="update#mantle.shipment.ShipmentItem"
                            in-map="[shipmentId:shipmentId, productId:testMachineOrderItem.productId, quantity:newSiQuantity]"/>

                    <if condition="newSiQuantity == 0.0">
                        <!-- if no ShipmentItems have quantity greater than 0.0 cancel Shipment -->
                        <entity-find-count entity-name="mantle.shipment.ShipmentItem" count-field="nonZeroShipItemCount">
                            <econdition field-name="shipmentId"/>
                            <econdition field-name="quantity" operator="greater" from="0.0"/>
                        </entity-find-count>
                        <if condition="nonZeroShipItemCount == 0">
                            <!-- cancel#Shipment won't do what it normally does reducing quantities, but just in case other cleanups needed -->
                            <service-call name="mantle.shipment.ShipmentServices.cancel#Shipment" in-map="[shipmentId:shipmentId]"/>
                        </if>
                    </if>
                </if>
            </iterate>

            <if condition="quantityCancelled == notIssuedQuantity"><then>
                <!-- if quantityCancelled == notIssuedQuantity remove all OrderItem Reservations -->
                <service-call name="mantle.product.AssetServices.remove#OrderItemReservations"
                              in-map="[testMachineOrderId:testMachineOrderId, testMachineOrderItemSeqId:testMachineOrderItem.testMachineOrderItemSeqId]"/>

            </then><else>
                <!-- reduce OrderItem Reservations by quantityCancelled? no need to, AssetReservation ECA rule will pick it up -->
            </else></if>
        </actions>
    </service>

    <!-- ============================================================== -->
    <!-- ========== Clone TestMachineOrder and Recurring TestMachineOrder Services ========== -->
    <!-- ============================================================== -->

    <service verb="clone" noun="TestMachineOrder">
        <description>Clone an order. Always copies the TestMachineOrderHeader and TestMachineOrderItem records.</description>
        <in-parameters>
            <parameter name="baseOrderId" required="true" default="testMachineOrderId"/>
            <parameter name="testMachineOrderId"/>
            <auto-parameters entity-name="beiyelin.testmachine.TestMachineOrderHeader" include="nonpk">
                <exclude field-name="parentOrderId"/><exclude field-name="lastOrderedDate"/></auto-parameters>

            <parameter name="requiredByDate" type="Timestamp"/>
            <parameter name="statusId" default-value="OrderOpen"/>
            <parameter name="entryDate" type="Timestamp" default="ec.user.nowTimestamp"/>
            <parameter name="visitId" default="ec.user.visitId"/>
            <parameter name="orderRevision" type="Integer" default="1"/>
            <parameter name="clearDates" type="Boolean" default="true"/>
            <parameter name="productItemsOnly" type="Boolean" default="true"/>
            <parameter name="copyContactMech" type="Boolean" default="true"/>
            <parameter name="copyContent" type="Boolean" default="true"/>
            <parameter name="copyNote" type="Boolean" default="true"/>
            <parameter name="copyPartParty" type="Boolean" default="true"/>
            <parameter name="copyTerm" type="Boolean" default="true"/>
            <parameter name="copyItemWorkEffort" type="Boolean" default="true"/>
            <parameter name="copyPayment" type="Boolean" default="true"/>
            <parameter name="paymentStatusId" default-value="PmntPromised"/>
        </in-parameters>
        <out-parameters><parameter name="testMachineOrderId"/></out-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader">
                <field-map field-name="testMachineOrderId" from="baseOrderId"/></entity-find-one>

            <!-- clear and sequence new testMachineOrderId -->
            <set field="testMachineOrderHeader.testMachineOrderId" from="null"/>
            <entity-sequenced-id-primary value-field="testMachineOrderHeader"/>

            <!-- set nonpk fields from context, if passed -->
            <entity-set value-field="testMachineOrderHeader" include="nonpk"/>

            <!-- set or clear fields related to testMachineOrder cloning and recurrence -->
            <set field="testMachineOrderHeader.parentOrderId" from="baseOrderId"/>
            <set field="testMachineOrderHeader.recurCronExpression" from="null"/>
            <set field="testMachineOrderHeader.lastOrderedDate" from="null"/>
            <set field="testMachineOrderHeader.recurAutoInvoice" from="null"/>

            <if condition="clearDates">
                <!-- set the fields even if null, don't do this for other fields -->
                <set field="testMachineOrderHeader.entryDate" from="entryDate"/>
                <set field="testMachineOrderHeader.placedDate" from="placedDate"/>
                <set field="testMachineOrderHeader.approvedDate" from="approvedDate"/>
                <set field="testMachineOrderHeader.completedDate" from="completedDate"/>
                <!-- don't set this on clones, used for recurring orders to track last date/time of clone/recurrence: <set field="testMachineOrderHeader.lastOrderedDate" from="lastOrderedDate"/> -->
            </if>

            <!-- create new OrderHeader -->
            <entity-create value-field="testMachineOrderHeader"/>
            <set field="testMachineOrderId" from="testMachineOrderHeader.testMachineOrderId"/>



            <entity-find entity-name="moqui.basic.EnumGroupMember" list="productItemTypeEgms" cache="true">
                <econdition field-name="enumGroupEnumId" value="EngItemsProduct"/></entity-find>
            <set field="productItemTypes" from="productItemTypeEgms*.enumId"/>

            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="valueList">
                <econdition field-name="testMachineOrderId" from="baseOrderId"/><order-by field-name="testMachineOrderItemSeqId"/></entity-find>


<!--            <if condition="copyContactMech">-->
<!--                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderPartContactMech" list="valueList">-->
<!--                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>-->
<!--                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>-->
<!--            </if>-->
            <if condition="copyContent">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderContent" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.testMachineOrderId" from="testMachineOrderId"/>
                    <set field="value.orderContentId" from="null"/>
                    <entity-sequenced-id-primary value-field="value"/>
                    <entity-create value-field="value"/>
                </iterate>
            </if>
            <if condition="copyNote">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderNote" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>
            </if>
<!--            <if condition="copyPartParty">-->
<!--                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderPartParty" list="valueList">-->
<!--                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>-->
<!--                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>-->
<!--            </if>-->
<!--            <if condition="copyTerm">-->
<!--                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderPartTerm" list="valueList">-->
<!--                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>-->
<!--                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>-->
<!--            </if>-->
            <if condition="copyItemWorkEffort">
                <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItemWorkEffort" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value"><set field="value.testMachineOrderId" from="testMachineOrderId"/><entity-create value-field="value"/></iterate>
            </if>

            <if condition="copyPayment">
                <entity-find entity-name="mantle.account.payment.Payment" list="valueList">
                    <econdition field-name="testMachineOrderId" from="baseOrderId"/></entity-find>
                <iterate list="valueList" entry="value">
                    <set field="value.testMachineOrderId" from="testMachineOrderId"/>
                    <set field="value.statusId" from="paymentStatusId"/>
                    <set field="value.paymentAuthCode" from="null"/><set field="value.paymentRefNum" from="null"/>
                    <set field="value.presentFlag" from="null"/><set field="value.swipedFlag" from="null"/>
                    <set field="value.processAttempt" from="null"/><set field="value.needsNsfRetry" from="null"/>
                    <set field="value.visitId" from="visitId"/>
                    <if condition="clearDates"><set field="value.effectiveDate" from="null"/></if>
                    <set field="value.paymentId" from="null"/>
                    <entity-sequenced-id-primary value-field="value"/>
                    <entity-create value-field="value"/>
                </iterate>
            </if>

            <message type="success">Created TestMachineOrder ${testMachineOrderId} as a clone of TestMachineOrder ${baseOrderId}</message>
        </actions>
    </service>

    <service verb="update" noun="OrderRecur">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="recurCronExpression" required="true"/>
            <parameter name="recurAutoInvoice" default-value="N"/>
            <parameter name="lastOrderedDate" type="Timestamp"/>
        </in-parameters>
        <actions>
            <!-- make sure testMachineOrder has no associated shipments or invoices -->
            <entity-find-count entity-name="beiyelin.testmachine.TestMachineOrderItemBilling" count-field="itemBillingCount">
                <econdition field-name="testMachineOrderId"/></entity-find-count>
            <if condition="itemBillingCount">
                <return error="true" message="TestMachineOrder ${testMachineOrderId} has been invoiced (billed), cannot make recurring"/></if>

            <entity-find-count entity-name="mantle.shipment.ShipmentItemSource" count-field="shipmentSourceCount">
                <econdition field-name="testMachineOrderId"/></entity-find-count>
            <if condition="shipmentSourceCount">
                <return error="true" message="TestMachineOrder ${testMachineOrderId} has been shipped, cannot make recurring"/></if>

            <!-- make sure cron expr is valid -->
            <script>
                try { org.moqui.impl.service.ScheduledJobRunner.getExecutionTime((String) recurCronExpression) } catch (Exception e) {
                    ec.message.addError("Invalid Cron expression '${recurCronExpression}': ${e.message}")
                    return
                }
            </script>

            <!-- update OrderHeader -->
            <service-call name="update#beiyelin.testmachine.TestMachineOrderHeader" in-map="context"/>

            <!-- cancel reservations if there are any -->
            <service-call name="mantle.product.AssetServices.remove#OrderReservations" in-map="[testMachineOrderId:testMachineOrderId]"/>

            <!-- TODO: don't allow AssetReservation, ShipmentItemSource, or OrderItemBilling for OrderHeader with recurCronExpression -->
        </actions>
    </service>

    <service verb="create" noun="RecurringOrders" authenticate="anonymous-all">
        <description>Called by scheduled ServiceJob to clone recurring orders, place, and try auto-approve</description>
        <actions>
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderHeader" list="orderHeaderList" cache="false">
                <econdition field-name="statusId" value="OrderApproved"/>
                <econdition field-name="recurCronExpression" operator="is-not-null"/>
                <select-field field-name="testMachineOrderId,recurCronExpression,lastOrderedDate"/>
                <order-by field-name="testMachineOrderId"/>
            </entity-find>
            <iterate list="orderHeaderList" entry="testMachineOrderHeader">
                <!-- check recurCronExpression vs lastOrderedDate to see if we need to run -->
                <set field="shouldRun" from="org.moqui.impl.service.ScheduledJobRunner.isLastRunBeforeLastSchedule(
                        testMachineOrderHeader.recurCronExpression, testMachineOrderHeader.lastOrderedDate, 'TestMachineOrder ' + testMachineOrderHeader.testMachineOrderId, null)"/>

                <if condition="shouldRun">
                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.create#RecurringOrder"
                            in-map="[baseOrderId:testMachineOrderHeader.testMachineOrderId]" async="distribute"/>
                </if>
            </iterate>
        </actions>
    </service>
    <service verb="create" noun="RecurringOrder" authenticate="anonymous-all">
        <in-parameters>
            <parameter name="baseOrderId" required="true"/>
        </in-parameters>
        <out-parameters>
            <parameter name="testMachineOrderId"/>
        </out-parameters>
        <actions>
            <!-- lock the testMachineOrder  -->
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="baseOrderHeader" for-update="true">
                <field-map field-name="testMachineOrderId" from="baseOrderId"/></entity-find-one>

            <if condition="!baseOrderHeader?.recurCronExpression">
                <return type="danger" message="TestMachineOrder ${baseOrderId} is not a recurring testMachineOrder (has no recur cron expression)"/></if>
            <if condition="baseOrderHeader?.statusId != 'OrderApproved'">
                <return type="danger" message="TestMachineOrder ${baseOrderId} is not in the Approved status"/></if>

            <!-- check again to make sure hasn't run since last execution time -->
            <set field="shouldRun" from="org.moqui.impl.service.ScheduledJobRunner.isLastRunBeforeLastSchedule(
                    baseOrderHeader.recurCronExpression, baseOrderHeader.lastOrderedDate, 'TestMachineOrder ' + baseOrderHeader.testMachineOrderId, null)"/>
            <if condition="!shouldRun"><return type="warning" message="TestMachineOrder ${baseOrderHeader.testMachineOrderId} is not yet scheduled to reorder since last testMachineOrder time ${baseOrderHeader.lastOrderedDate}"/></if>

            <!-- clone the testMachineOrder -->
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.clone#TestMachineOrder" out-map="cloneOut" in-map="[baseOrderId:baseOrderId]"/>
            <set field="testMachineOrderId" from="cloneOut.testMachineOrderId"/>

            <!-- Place the TestMachineOrder -->
            <service-call name="beiyelin.testmachine.TestMachineOrderServices.place#TestMachineOrder" in-map="[testMachineOrderId:testMachineOrderId, requireInventory:false]"/>


            <!-- set lastOrderedDate on recurring testMachineOrder -->
            <set field="baseOrderHeader.lastOrderedDate" from="ec.user.nowTimestamp"/>
            <entity-update value-field="baseOrderHeader"/>
        </actions>
    </service>

    <!-- ==================================================== -->
    <!-- ========== TestMachineOrder Change Response Services ========== -->
    <!-- ==================================================== -->

    <service verb="handle" noun="TestMachineOrderItemChange">
        <description>Called by EECA rule on TestMachineOrderItem create/update/delete</description>
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="testMachineOrderItemSeqId"/>
            <parameter name="itemTypeEnumId"/>
            <parameter name="quantity" type="BigDecimal"/>
            <parameter name="unitAmount" type="BigDecimal"/>
            <parameter name="selectedAmount" type="BigDecimal"/>
            <parameter name="isPromo"/>
            <parameter name="originalValue" type="Map"/>
            <parameter name="eecaOperation"/>
        </in-parameters>
        <actions>
            <if condition="eecaOperation == 'delete'">
<!--                <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#OrderPartTotal" in-map="context"/>-->
                <!-- NOTE: OrderServices.handle#TestMachineOrderMajorChange is called by delete#OrderItem -->
                <return/>
            </if>

            <if condition="!originalValue || quantity != originalValue.quantity || unitAmount != originalValue.unitAmount ||
                    selectedAmount != originalValue.selectedAmount " ><then>
<!--                <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true"/>-->
<!--                <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#OrderPartTotal" in-map="context"/>-->
<!--                <if condition="originalValue &amp;&amp; orderPartSeqId != originalValue.orderPartSeqId">-->
<!--                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.update#OrderPartTotal"-->
<!--                            in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:originalValue.orderPartSeqId]"/>-->
<!--                </if>-->

<!--                <if condition="testMachineOrderHeader.productStoreId &amp;&amp; isPromo != 'Y' &amp;&amp; !(itemTypeEnumId in ['ItemShipping', 'ItemSalesTax', 'ItemVatTax'])">-->
<!--                    <service-call name="beiyelin.testmachine.TestMachineOrderServices.handle#TestMachineOrderMajorChange"-->
<!--                            in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId]"/>-->
<!--                    <if condition="originalValue &amp;&amp; orderPartSeqId != originalValue.orderPartSeqId">-->
<!--                        <service-call name="beiyelin.testmachine.TestMachineOrderServices.handle#TestMachineOrderMajorChange"-->
<!--                                in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:originalValue.orderPartSeqId]"/>-->
<!--                    </if>-->
<!--                </if>-->
                <!-- NOTE: no need to increment#OrderRevision, will be done when part updated -->
            </then><else>
                <!-- increment testMachineOrder revision if anything else changes on an item -->
                <service-call name="beiyelin.testmachine.TestMachineOrderServices.increment#OrderRevision" in-map="context"/>
            </else></if>
        </actions>
    </service>

    <service verb="handle" noun="TestMachineOrderMajorChange">
        <in-parameters>
            <parameter name="testMachineOrderId" required="true"/>
            <parameter name="orderPartSeqId" required="true"/>
            <parameter name="testMachineOrderHeader" type="EntityValue"/>
        </in-parameters>
        <actions>
            <!-- use ec.context.sharedMap for a reentrant semaphore (sort of, not thread safe but all needed to prevent incorrect/infinite recursion) -->
            <set field="sharedFlagKey" from="'TestMachineOrderMajorChange' + testMachineOrderId + orderPartSeqId"/>
            <if condition="ec.context.getSharedMap().get(sharedFlagKey)"><return/></if>

            <if condition="testMachineOrderHeader == null"><entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true"/></if>
            <if condition="testMachineOrderHeader.productStoreId">
                <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderPart" value-field="orderPart" for-update="true"/>
                <set field="noRecalcStatuses" from="['OrderApproved', 'OrderSent', 'OrderCompleted', 'OrderRejected', 'OrderCancelled']"/>
                <if condition="testMachineOrderHeader.statusId in noRecalcStatuses">
                    <return type="warning" message="Not updating promotions, shipping, or tax for testMachineOrder ${testMachineOrderId} in status ${testMachineOrderHeader.status?.description}"/></if>
                <if condition="orderPart.statusId in noRecalcStatuses">
                    <return type="warning" message="Not updating promotions, shipping, or tax for testMachineOrder part ${testMachineOrderId}:${orderPartSeqId} in status ${orderPart.status?.description}"/></if>

                <!-- make sure no billing done, don't auto update if so -->
                <entity-find-count entity-name="beiyelin.testmachine.TestMachineOrderItemBillingDetail" count-field="partBillingCount">
                    <econdition field-name="testMachineOrderId"/><econdition field-name="orderPartSeqId"/></entity-find-count>
                <if condition="partBillingCount">
                    <return type="warning" message="Not updating promotions, shipping, or tax for testMachineOrder part ${testMachineOrderId}:${orderPartSeqId} with ${partBillingCount} OrderItemBilling records"/></if>

                <!-- set flag in context root to avoid recursive triggers -->
                <script>ec.context.getSharedMap().put(sharedFlagKey, true)</script>

                <!-- Apply Promotions -->
                <if condition="!'Y'.equals(orderPart.disablePromotions)">
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="promoItemList">
                        <econdition field-name="testMachineOrderId"/><econdition field-name="orderPartSeqId"/>
                        <econdition field-name="isPromo" value="Y"/>
                    </entity-find>
                    <iterate list="promoItemList" entry="promoItem">
                        <service-call name="beiyelin.testmachine.TestMachineOrderServices.delete#OrderItem"
                                in-map="[testMachineOrderId:promoItem.testMachineOrderId, testMachineOrderItemSeqId:promoItem.testMachineOrderItemSeqId]"/>
                    </iterate>
                    <service-call name="mantle.product.PromotionServices.apply#OrderPromotions"
                            in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId, testMachineOrderHeader:testMachineOrderHeader]"/>
                </if>

                <!-- Check for promotions with free ground shipping (if shipmentMethodEnumId == ShMthGround) -->
                <set field="doShipCalc" from="true"/>
                <if condition="'ShMthGround'.equals(orderPart.shipmentMethodEnumId)">
                    <!-- get promotions applied -->
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="shipPromoItemList" distinct="true">
                        <econdition field-name="testMachineOrderId"/><econdition field-name="orderPartSeqId"/>
                        <econdition field-name="isPromo" value="Y"/>
                        <econdition field-name="storePromotionId" operator="is-not-null"/>
                        <select-field field-name="storePromotionId"/>
                    </entity-find>
                    <!-- this may look inefficient, but the best way to get arbitrary set of cached ProductStorePromotion values -->
                    <iterate list="shipPromoItemList" entry="shipPromoItem">
                        <entity-find-one entity-name="mantle.product.store.ProductStorePromotion" value-field="storePromotion" cache="true">
                            <field-map field-name="storePromotionId" from="shipPromoItem.storePromotionId"/></entity-find-one>
                        <if condition="'Y'.equals(storePromotion?.freeGroundShipping)">
                            <set field="doShipCalc" from="false"/>
                            <break/>
                        </if>
                    </iterate>
                </if>

                <!-- Calculate Shipping, after promotions so that testMachineOrder total/etc is adjusted for them -->
                <if condition="!'Y'.equals(orderPart.disableShippingCalc)">
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="shippingItemList">
                        <econdition field-name="testMachineOrderId"/><econdition field-name="orderPartSeqId"/>
                        <econdition field-name="itemTypeEnumId" value="ItemShipping"/>
                    </entity-find>
                    <iterate list="shippingItemList" entry="shippingItem">
                        <service-call name="beiyelin.testmachine.TestMachineOrderServices.delete#OrderItem"
                                in-map="[testMachineOrderId:shippingItem.testMachineOrderId, testMachineOrderItemSeqId:shippingItem.testMachineOrderItemSeqId]"/>
                    </iterate>
                    <if condition="doShipCalc">
                        <service-call name="mantle.shipment.CarrierServices.calculate#OrderPartShipping"
                                in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId, createOrderItem:true]"/>
                    </if>
                </if>

                <!-- Calculate Tax, after Shipping as it might be taxed -->
                <if condition="!'Y'.equals(orderPart.disableTaxCalc)">
                    <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="taxItemList">
                        <econdition field-name="testMachineOrderId"/><econdition field-name="orderPartSeqId"/>
                        <econdition field-name="itemTypeEnumId" operator="in" value="ItemSalesTax,ItemVatTax"/>
                    </entity-find>
                    <iterate list="taxItemList" entry="taxItem">
                        <service-call name="beiyelin.testmachine.TestMachineOrderServices.delete#OrderItem"
                                in-map="[testMachineOrderId:taxItem.testMachineOrderId, testMachineOrderItemSeqId:taxItem.testMachineOrderItemSeqId]"/>
                    </iterate>
                    <service-call name="mantle.other.TaxServices.calculate#OrderSalesTax"
                            in-map="[testMachineOrderId:testMachineOrderId, orderPartSeqId:orderPartSeqId]"/>
                </if>

                <script>ec.context.getSharedMap().remove(sharedFlagKey)</script>

                <service-call name="beiyelin.testmachine.TestMachineOrderServices.increment#OrderRevision" in-map="context"/>
            </if>
        </actions>
    </service>

    <service verb="update" noun="OrderHeaderTotal">
        <description>Update OrderHeader.grandTotal based on OrderItem.amount values </description>
        <in-parameters>
            <parameter name="testMachineOrderId"/>
        </in-parameters>
        <actions>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true"/>
            <set field="totalSum" from="0.0" type="BigDecimal"/>
            <entity-find entity-name="beiyelin.testmachine.TestMachineOrderItem" list="orderItemList"><econdition field-name="testMachineOrderId"/></entity-find>
            <iterate list="orderItemList" entry="orderItem">
                <set field="totalSum" from="totalSum + (orderItem.amount ?: 0)"/>
            </iterate>
            <set field="testMachineOrderHeader.grandTotal" from="totalSum"/>
            <entity-update value-field="testMachineOrderHeader"/>
        </actions>
    </service>

    <service verb="increment" noun="OrderRevision">
        <in-parameters>
            <parameter name="testMachineOrderId"/>
        </in-parameters>
        <actions>
            <if condition="!testMachineOrderId"><return/></if>
            <entity-find-one entity-name="beiyelin.testmachine.TestMachineOrderHeader" value-field="testMachineOrderHeader" for-update="true">
                <field-map field-name="testMachineOrderId"/></entity-find-one>
            <!-- TODO: not using <select-field field-name="testMachineOrderId,orderRevision"/> because of issue in EntityValue where a bunch of stuff gets set to null -->
            <if condition="testMachineOrderHeader != null">
                <set field="testMachineOrderHeader.orderRevision" from="(testMachineOrderHeader.orderRevision ?: 1) + 1"/>
                <entity-update value-field="testMachineOrderHeader"/>
            </if>
        </actions>
    </service>


</services>
